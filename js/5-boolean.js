// 5 тема - js (Основы типа Boolean)



// 1. Какие есть операторы сравнения? (8 шт) +

// Равно(==)
// Не равно(!=)
// Строго равно(===) - Возвращает true, если операнды строго равны, без преобразования типов.
// Строго не равно(!==)

// Больше(>)
// Больше или равно(>=)
// Меньше(<)
// Меньше или равно(<=)



// 2. К какому типу данных неявно приводятся переменные при сравнении с числом? +
// Ответ: число.

// Если два операнда не одного типа, javascript преобразовывает типы и сравнивает строго. 
// Если какой-либо операнд - число или булево значение, то операнды преобразуются в числа.
// если какой-либо операнд строка - второй преобразуются в строку.



// 3. Какие есть логические операторы? + -

// В JavaScript есть четыре логических оператора: || (ИЛИ), && (И) и ! (НЕ), ?? (Оператор нулевого слияния).

//Оператор нулевого слияния(??) — это логический оператор, возвращающий значение правого операнда, если значение левого операнда содержит null или undefined, в противном случае возвращается значение левого операнда.



// 4. К какому типу данных неявно приводятся переменные при работе с логическими операторами? + -

// true или false



// 5. Таблица истинности всех логических операторов (понимать/знать, как работает) + -

// https://dorey.github.io/JavaScript-Equality-Table/ топ таблица
// где === все понятно
// где == есть еще вопросы + -



// 6. Как проверить число на NaN? +

// Функция «isNaN()» при проверке вернет «true» в двух случаях: если при проверке значение уже NaN и если оно станет NaN после попытки преобразования его в число;
// метод «Number.isNaN()» вернет «true» только если значение при проверке уже является NaN.



// 7. Что будет в переменной, если сравнить: ('Я' > 'А') Почему? +

// let test = 'Я' > 'А';
// console.log(test);

// Вернет true, потому что строки равны



// 8. Чем отличается == от ===? +

// Оператор == сравнивает на равенство, а вот === — на идентичность. Плюс оператора === состоит в том, что он не приводит два значения к одному типу. Именно из-за этого он обычно и используется.



// 9. +

// == двойное может неявно приводить к нужному типу и сравнивать, поэтому true.
// === нет приведения, точное сравненение поэтому false

//console.log(false == 0)? true
//console.log("0" == false)? true
// console.log(null == undefined)? true
// console.log(null === undefined)? false



// 10. C помощью какой функции можно явно преобразовать к типу boolean? +

// Boolean()



// 11. Что будет, если явно преобразовать к типу boolean следующие значения: +
// если есть есть значение то покажет true, если его нет то false. 

// * String
// "" - пустая строка
// "0" - строка с числом
// " " - строка с одним пробелом
// "t" - строка с текстом

console.log(Boolean("")); //false тут пустая строка
console.log(Boolean("0")); //true
console.log(Boolean(" ")); //true тут пробел
console.log(Boolean("t")); //true

// * Number
// NaN
// 0
// 1
// 3
// -3

console.log(Boolean("NaN")); //true
console.log(Boolean("0")); //true
console.log(Boolean("1")); //true
console.log(Boolean("3")); //true
console.log(Boolean("-3")); //true

// * null & undefined

// undefined
// null

console.log(Boolean(null)); // false null значение для ничего, в контексте логических операций, рассматривается как ложное
console.log(Boolean(undefined)); // false еще не присвоено значение
